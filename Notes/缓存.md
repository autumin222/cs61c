# 缓存

想要内存具有足够大的空间，同时想要拥有很好的内存读写速度

## 内存层次结构

距离处理器的距离由近到远依次为：寄存器，缓存，内存，硬盘

如果距离处理器越近：

* 空间越小

* 访问速度越快

* 更昂贵

* 是低层内容的子集（包含最常使用的数据）

缓存被集成在cpu上，并且对于指令集和数据集有分离的缓存

### 内存层次技术

* 缓存使用了静态RAM（SRAM）
  
  * 更快，更贵
  
  * 静态：通电情况下数据维持不变

* 主内存使用动态RAM（DRAM）
  
  * 更便宜，更慢
  
  * 动态：需要时长刷新

* 时间空间局部性
  
  * 时间局部性：在之前一段时间访问的数据，在之后很可能被访问
  
  * 空间局部性：在内存一个位置的数据被访问，那它的邻居也很可能被访问

## 缓存

### 缓存设计

* 组织缓存

* 确定内存映射
  
  一个缓存地址可能对应着多个内存地址

* 缓存里有哪些数据

* 快速查找数据

实际上，数据从内存移动到缓存中的过程由缓存控制器控制（硬件）

### 直接映射缓存

缓存是按块（block）划分的，缓存的大小等于缓存块数*缓存块大小

* 内存比缓存大得多，所以**缓存的一个块对应多个内存地址**

#### 地址映射

以类似轮转的方式映射内存地址，如果缓存块数为4，那么映射到第0块的地址为模4余0的地址，即最低两位比特为00的地址

* 当缓存块的字节数大于1时，在确定内存对应的缓存号后，还需要考虑在缓存中的偏移量offset

* 在缓存中明确数据是否可用，判断来自哪个内存地址

#### 地址分段分析

将地址分为三段，分别用于确定缓存号、缓存行，缓存列

* **Index**（中间）
  
  指出需要查找哪个缓存块号，**位数代表块数**

* **Offset**（最末）
  
  确定将字节数据储存到块中的哪个位置——确定偏移量
  
  **位数代表块宽度（字节数）**

* **Tag**（高位）
  
  剩余的位用于区分那些将映射到同一个位置的内存地址（分组）

**Index 和 Offset 所需的位即缓存的大小**

#### 确认是否命中

通过缓存控制器中的缓存表确认，每一个表项对应高速缓存中的line行。表项由标签tag（n位）和表示状态的几个flag组成

* 通过缓存表可以知道缓存中储存的数据来自哪个内存地址

#### 直接映射过程

从零开始（warming cache）

1. 地址拆分，获取T，I，O

2. 通过 Index 找到映射后在缓存的哪一行

3. 检查有效位，如果有效位为0（miss），意味着缓存内为垃圾值

4. 有效位置为1

5. 设置 Tag 位

6. 在**缓存块**中装填内存中对应的数据（一次装填一整块，即使并没有访问需求）

7. 通过 offset 查找数据，返回

检查顺序依次为 Index，Valid bit，Tag。若全部命中，则通过offset返回值

### 写策略

写入的地址是否在缓存中有映射，有则命中

#### 写命中

* 多次读写同一地址时，如果每次都要直接到内存中更新（write through），则可能需要耗费很多时间

* 而在缓存中直接修改，在适当时候再写回内存（write back）可以提高效率

##### 全写write-through

缓存和内存同时更新

##### 写回write-back

在缓存块中添加dirty bit，如果为1，意味着缓存数据与内存不一致，当**块替换**的时候会**更新内存**

**两者在不同条件下权衡使用**

#### 写未命中

##### 写分配

加载主存中块到 Cache 中，然后更新这个块，缺点就是每次不命中都要从主存中读取一块

##### 非写分配

只写入主存，不进行调块

#### 总结

* **非写分配**通常与**全写**配合，**写分配**法和**写回**法配合

* 多级缓存中，缓存之间一般采用**全写**，缓存与内存之间采用**写回**

### 块大小

* 增加块的大小可以更好的利用空间局部性，使得一次从内存中获取了更多的数据，提高了后续访问这些数据的速度

* 但如果块过大（对于整个缓存大小），则会减少行数Index，使得命中率降低，并且每次更新缓存都需要从内存带回更多的数据，使得miss penalty更大

**随着块越大，未命中惩罚越大，未命中率先降低后升高，即平均时间先降低后升高，存在一个块大小值使得平均访问时间最低**

### MISSES未命中

1. 强制未命中Complusory Miss
   
   在缓存刚开始预热时，所有**有效位都为0**，此时访问需要更新。这是每个缓存块都需要的启动状态

2. 冲突未命中Conflict Misses
   
   因为有多个内存地址映射到同一个缓存块中，即**Tag不符合**，则会miss

3. 容量未命中Capacity Misses
   
   **缓存容量不足**时，对于全关联缓存，如果每个缓存块都被标记为1后，后续的映射会发生

##### 全关联缓存——解决冲突未命中

取消Index，每次都在缓存中通过Tag查找（通过硬件并行验证）

* 意味着Tag位数变多了

* 并行比较验证的硬件很难实现（数量多时）

##### 组关联缓存

* 一个Index指明一个组

* 每个组包含多个块（通常为二的幂）

* 在组内进行并行的Tag比较（通过硬件）——可实现的，因为规模更小

**当一个组只包含一个块时，为直接关联缓存；当只有一个组包含所有的块时，为全关联缓存**

### 块替换策略

当所有块的有效位都是1，即缓存已满时，**选择一个块，将新的数据放进去**

1. 最近最少使用（least Recently Used）
   
   依据的是时间局部性，最近很少使用的块的数据下次再被使用的概率很低
   
   * 缺点是需要追踪块的访问顺序，在两路组关联中很容易用硬件实现（一个LRU位，表明最近未使用）

2. FIFO

3. Random

### 平均内存访问时间AMAT

对于一级缓存

$AMAT =命中时间+未命中惩罚 \times 未命中率$

使用多级缓存（三层）

* 上一层的未命中惩罚 = 下一层AMAT
