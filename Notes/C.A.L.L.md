## 编译器

将高级语言转换为汇编语言

* 输出可能含有伪指令

* 编译不简单

## 汇编器

将汇编语言转换为对象代码和信息表

* 转换伪指令

* 生成机器码

### 汇编指令

操作汇编器，不生成机器码（`.text .data .word`）

### 生成机器码

包括简单的计算（通过数据）和分支跳转（通过地址）

#### “向前参考”问题

分支语句需要访问程序“前方的”标签

所以我们需要**两次遍历**程序

1. 一次遍历
   
   * 拓展伪指令
   
   * 记住标签位置
   
   * 移除注释，空行等对代码进行压缩
   
   * 错误检查

2. 第二次遍历
   
   * 通过标签位置生成相关联的地址（分支跳转）
   
   * 输出对象文件（二进制代码集文件）

#### 程序外部连接

* 符号表
  
  记录可以对其他文件使用的对象（每个文件独有）
  
  包括标签和数据

* 转移表
  
  记录该文件稍后需要的地址（目前未确定，由链接器处理）
  
  包括**外部标签跳转（外部函数调用），外部数据使用**

#### 对象文件格式

1. 文件头：记录其他部分的位置和大小

2. 文本片：机器码

3. 数据片：源文件的数据

4. 转移表

5. 符号表

6. debug信息（标准ELF格式）

## 链接器

通过对象文件和信息表获得可执行代码

* 链接了许多对象文件，获得一个可执行文件

* 使得文件可以**分别编译**
  
  单一文件修改不必重新编译所有文件
  
  编辑文件件的链接跳转

### 过程

1. 把文本片拿出来放在一起

2. 数据片放在一起，放在文本片的末尾

3. 处理引用
   
   * **填充转移表**所有条目，使用绝对地址

#### 三种地址类型

1. pc相关的地址（不需要转移）

2. 外部函数引用（需要转移）

3. 静态数据引用（需要转移）

#### RISC-V的绝对地址

* 与跳转链接代码（jal）相关

* 静态区域的变量存取（与全局指针相关）

### 处理引用

* 链接器假定第一个文本片的第一个字储存在0x10000

* 链接器知道每段文本片和数据片的长度及其顺序

* 计算出每个标签的绝对地址以及每个被引用的数据

要解决引用

1. 在所有使用符号表的文件里查找引用

2. 没找到则继续在库文件里查找

3. 确定绝对地址后将其填充到机器码里

## 装载器

执行可执行程序

* 可执行的文件储存在硬盘里

* 需要执行时，装载器把它加载到内存中并开始执行

* 实际上，装载器就是操作系统（的一个任务）

#### 运行过程

1. 通过可执行文件**头部信息**，确定**文本片和数据片**的大小

2. 在栈段中创建一个足够大的**地址空间来储存**文本片和数据片

3. **移动**文本和数据到新开辟的地址中

4. 将程序的**参数移动**到**栈**上

5. **初始化**机器的寄存器
   
   * 清除大多数寄存器，但堆栈指针给第一个空闲堆栈位置分配了地址

6. 跳转到**启动例程**，该例程将程序的参数从堆栈复制到寄存器并设置PC
   
   * 如果主例程返回，启动例程用exit系统调用终止程序
