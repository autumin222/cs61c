# 危害

意味着在下一个时钟周期未能启动下一条指令

* 结构危害
  
  关于资源请求

* 数据危害
  
  数据在不同指令间流动，需要等待上一条数据的读写

* 控制危害
  
  关于控制流

## 结构危害

由于流水线中的两条指令竞争同一个资源

### 解决

1. 停滞：下一条指令需要等待上一条指令使用完该资源

2. 添加更多硬件，使得所有指令可以同时执行

以寄存器堆为例，具有两个读地址输入，一个写地址输入。意味着每个周期可以发生三个访问

#### 竞争内存

读写都需要使用内存，但是如果只有一个内存或是没有采用分离内存技术，那么获取指令阶段需要在当前周期**停滞**

结构危害确实存在，但可以通过与ISA相匹配的硬件设计来避免

## 数据危害

### 同时读写

当一个指令执行需要向寄存器里**写入值**，而另一条指令想要在同一个寄存器里**读取值**，那么就会不明确到底读取到的是新值还是旧值

#### 解决

在risc-v中，寄存器支持在**一个时钟周期内读写**，例如周期为200ps，读写分别需要100ps，那么寄存器会先写再读，也就是说**读取到的值为新值**，这对**大多数标准五级流水线**来说都是正确的

### 未写先读

我们期望每条指令按顺序执行，这意味着**下一条指令执行时依赖上一条指令的结果**，比如上一步向s0写入数据，修改了s0的值，那么下一步执行时s0的值**应该是修改后的值而不是未修改的值**

#### 解决

1. 停滞：在上一条指令未完成修改时，下一条指令**保持等待**（**推迟到读写同一周期**：刚好完成写回，立即读取）
   
   * *缺点**：处理器在推迟完成之前不会进行任何操作（称作冒泡），造成**性能下降**
   
   实际上，**编译器**会努力避免这个问题，通过**调整指令的执行顺序**，使得那些不需要使用s0的指令先执行。但并不是总能找到

2. 硬件方案（旁路转发）：通过一定的方式，使得ALU输出的值，在未写回到目标寄存器时，先通过一定的结构被后续指令获取到。即**上一条指令的ALU输出快速转发到下一条指令的ALU输入**（不经过寄存器堆）

### 数据加载

加载指令从一个内存中获取值，写回到目的寄存器中

由于必须在**内存读取阶段结束后才能获取值**，这导致第二条指令需要输入值到ALU开始执行命令时，上一条指令的目标值还没有获取到（**一个周期**之后才从内存中获取）

#### 解决

1. **停滞等待一个周期**
* 在获取到指令之后，如果使用了上一条加载指令的目标寄存器，则**使当前指令无效，然后在下一个周期执行**

**硬件实施**：**禁用所有控制信号**，所有元件状态都不更新（PC也不更新），所以**执行下一条指令完全相同**但推迟了一个周期，这时**再使用旁路转发**即可

2. **编译器调整指令顺序**
   
   使得加载命令之后不紧跟需要使用该目的寄存器的命令，从而延迟周期

### 总结

数据危害的处理方式跟**指令之间存在的周期延迟**有关

* 若是需要的数据还需要**一个周期才能得到**，则**停滞一个周期**

* 若是数据已经得到，但**还没有写回**，则通过**旁路转发**，在写**回寄存器前先交给ALU**执行计算

* 若是数据**正在写回**寄存器，而下一条指令又需要**从寄存器读值**，则通过硬件设计，使得寄存器可以**在一个周期同时读写**（先写后读）

并且可以从编译器开始预防这些危害，通过调整指令的顺序，**尽量使得数据在处理好后再被使用**

## 控制危害

对于一个分支语句（例如beq），直到ALU计算出结果之前（需要两个周期），都不知道是否需要跳转

### 解决

1. 单纯停滞两个周期——显然造成过大的损失

2. 继续执行后面两条指令，直到ALU给出结果：
   
   * 如果不需要跳转，则继续执行
   
   * 如果需要跳转，则将后面两条指令无效（转换为nop），然后设置PC以执行后续命令

3. **分支预测**。如果预测该分支会执行，则立即跳转到对应标签。直到分支是否执行的真正结果出来后再进行纠正，如果预测出错则返回之前的位置执行接下来的代码
   
   * 当然大多数时候预测都是正确的，不需要两个两个周期
